{"version":3,"sources":["PP.js","Landing.js","data.js","List.js","App.js","serviceWorker.js","index.js"],"names":["PP","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","onButtonClick","data","script","state","value","language","versionIndex","clientId","clientSecret","stdin","setState","loading","fetch","method","mode","cache","credentials","headers","Accept","Content-Type","Origin","Access-Control-Allow-Headers","Access-Control-Allow-Origin","redirect","referrer","body","JSON","stringify","then","res","json","output","_this2","react_default","a","createElement","className","style","paddingTop","href","props","location","title","description","cerinta","din","dout","concat","rezolvare","width","rows","onChange","event","target","disabled","textAlign","alignContent","justifyContent","onClick","dist_default","name","alignSelf","React","Component","Landing","id","height","position","top","left","marginRight","transform","List","class","marginTop","map","obj","i","Link","key","to","pathname","App","console","log","BrowserRouter","Fragment","type","htmlFor","Route","path","exact","component","Boolean","window","hostname","match","ReactDOM","render","src_App","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.2e5907c3.chunk.js","sourcesContent":["import React from 'react';\r\nimport Spinner from 'react-spinkit';\r\n\r\nclass PP extends React.Component {\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n            value: '',\r\n            res: { output: 'Nu a fost nimic compilat inca!' },\r\n            loading: false\r\n        }\r\n    }\r\n    onButtonClick = () => {\r\n        let data = {\r\n            script: this.state.value,\r\n            language: \"cpp\",\r\n            versionIndex: \"3\",\r\n            clientId: \"3ab058b2c56e83895ea733b3e0449bf5\",\r\n            clientSecret: \"9f0db5c8938a159a2a11dfb279ea32152c3a0ad715a2c201441a3b347f90fcb0\",\r\n            stdin: \"5 5 2 1 2 5 1 3 2 4 5 1 4\"\r\n        }\r\n        this.setState({ loading: true })\r\n        fetch('https://cors-anywhere.herokuapp.com/https://api.jdoodle.com/v1/execute', {\r\n            method: \"POST\",\r\n            mode: \"cors\",\r\n            cache: \"no-cache\",\r\n            credentials: \"same-origin\",\r\n            headers: {\r\n                'Accept': 'application/json',\r\n                'Content-Type': 'application/json',\r\n                'Origin': '*',\r\n                'Access-Control-Allow-Headers': '*',\r\n                'Access-Control-Allow-Origin': '*',\r\n            },\r\n            redirect: \"follow\",\r\n            referrer: \"no-referrer\",\r\n            body: JSON.stringify(data)\r\n        }\r\n        ).then(res => res.json())\r\n            .then(res => this.setState({ res: res, loading: false }))\r\n    }\r\n    render() {\r\n        return (\r\n            <article className=\"article\" style={{ paddingTop: 20 }}>\r\n                <h1 className=\"article-title\"><a href=\"\">{this.props.location.state.title}</a></h1>\r\n                <p className=\"article-meta\">Scrisa de <a href=\"https://www.facebook.com/vladromila\">Vlad Romila</a></p>\r\n                <p className=\"text-lead\">\r\n                {this.props.location.state.description}\r\n                </p>\r\n                <h3 className=\"article-title\"><a href=\"\">Cerinta</a></h3>\r\n                <p className=\"text-lead\">\r\n                   {this.props.location.state.cerinta}\r\n                </p>\r\n                <h3 className=\"article-title\"><a href=\"\">Date de intrare</a></h3>\r\n                <p className=\"text-lead\">\r\n                   {this.props.location.state.din}\r\n                </p>\r\n                <h3 className=\"article-title\"><a href=\"\">Date de iesire</a></h3>\r\n                <p className=\"text-lead\">\r\n                    {this.props.location.state.dout}\r\n                </p>\r\n                <h3 className=\"article-title\"><a href=\"\">Rezolvare</a></h3>\r\n                <pre><code>\r\n                    {`${this.props.location.state.rezolvare}`}\r\n                </code></pre>\r\n                <h3 className=\"article-title\"><a href=\"\">Compilare(nu functioneaza cu fisiere, doar citire de la tastatura)</a></h3>\r\n                <textarea style={{ width: '100%' }} rows={15}\r\n                    value={this.state.value}\r\n                    onChange={(event) => this.setState({ value: event.target.value })}\r\n                    disabled={this.state.loading}\r\n                ></textarea>\r\n                <div className=\"col-12 col\" style={{ textAlign: 'center', alignContent: 'center', justifyContent: 'center' }}>\r\n                    <button disabled={this.state.loading} className=\"btn-block\" onClick={this.onButtonClick}>Trimite</button>\r\n                </div>\r\n                <h3 className=\"article-title\"><a href=\"\">Date de iesire</a></h3>\r\n                <div className=\"sm-3 col border border-primary\">{this.state.loading === false ? this.state.res.output : <Spinner name=\"pacman\" style={{ alignSelf: 'center' }} />}</div>\r\n            </article>\r\n        )\r\n    }\r\n}\r\nexport default PP;","import React from 'react';\r\n\r\nconst Landing = () => {\r\n    return (\r\n            <div id=\"landingdiv\" style={{ width: '100%', height: '100%', textAlign: 'center' }}>\r\n                <h1 style={{\r\n                    position: 'absolute',\r\n                    top: '30%',\r\n                    left: '50%',\r\n                    marginRight: '-50%',\r\n                    transform: 'translate(-50%, -50%)'\r\n                }}>Teoria grafurilor</h1>\r\n            </div>\r\n\r\n    )\r\n}\r\nexport default Landing","\r\nexport const data = [\r\n    {\r\n        title:'Afisare matrice de adiacenta dupa citirea a m muchii',\r\n        cerinta:'Sa se afiseze matricea de adiacenta in urma citirii de la tastatura a unui numar n=numar de noduri si un numar m=numar de muchii si a m perechi de extremitati de muchii',\r\n        din:'Se citeste de la tastatura un numar n=numar de noduri si un numar m=numar de muchii si m perechi de extremitati de muchii',\r\n        dout:'Sa se afiseze matricea de adiacenta',\r\n        rezolvare:\r\n        `#include <iostream>\r\n        using namespace std;\r\n        int a[120][120],n,m;\r\n        void citire()\r\n        {\r\n            cin>>n>>m;\r\n            int x,y;\r\n            for(int i=1; i<=m; i++)\r\n            {\r\n                cin>>x>>y;\r\n                a[x][y]=a[y][x]=1;//la graf orientat spunem ca doar a[x][y]=1;\r\n            }\r\n        }\r\n        void afisare()\r\n        {\r\n            for(int i=1; i<=n; i++)\r\n            {\r\n                for(int j=1; j<=n; j++)\r\n                    cout<<a[i][j]<<\" \";\r\n                cout<<endl;\r\n            }\r\n        }\r\n        int main()\r\n        {\r\n            citire();\r\n            afisare();\r\n        }\r\n        `\r\n    },\r\n    {\r\n        title:'Afisare matrice de incidenta dupa citirea a m muchii',\r\n        cerinta:'Sa se afiseze matricea de incidenta in urma citirii de la tastatura a unui numar n=numar de noduri si un numar m=numar de muchii si a m perechi de extremitati de muchii',\r\n        din:'Se citeste de la tastatura un numar n=numar de noduri si un numar m=numar de muchii si m perechi de extremitati de muchii',\r\n        dout:'Sa se afiseze matricea de incidenta',\r\n        rezolvare:\r\n        `#include <iostream>\r\n        using namespace std;\r\n        int in[120][120],n,m;\r\n        void citire()\r\n        {\r\n            cin>>n>>m;\r\n            int x,y;\r\n            for(int i=1; i<=m; i++)\r\n            {\r\n                cin>>x>>y;\r\n                in[y][i]=in[x][i]=1;\r\n            }\r\n        }\r\n        void afisare()\r\n        {\r\n            for(int i=1; i<=n; i++)\r\n            {\r\n                for(int j=1; j<=m; j++)\r\n                    cout<<in[i][j]<<\" \";\r\n                cout<<endl;\r\n            }\r\n        }\r\n        int main()\r\n        {\r\n            citire();\r\n            afisare();\r\n        }        \r\n        `\r\n    },\r\n    {\r\n        title:'Afisarea lanturilor unui graf neorientat',\r\n        cerinta:'Sa se afiseze lanturile unui graf neorientat',\r\n        din:'Se citeste de la tastatura un numar n=numar de noduri si un numar m=numar de muchii si m perechi de extremitati de muchii',\r\n        dout:'Sa se afiseze lanturile grafului neorientat dat',\r\n        rezolvare:\r\n        `#include <bits/stdc++.h>\r\n\r\n        using namespace std;\r\n        ifstream fin(\"date.in\");\r\n        ofstream fout(\"date.out\");\r\n        int a[120][120],n,m,viz[120];\r\n        void citire()\r\n        {\r\n            fin>>n>>m;\r\n            int x,y;\r\n            for(int i=1; i<=m; i++)\r\n            {\r\n                fin>>x>>y;\r\n                a[x][y]=a[y][x]=1;\r\n            }\r\n        }\r\n        void rw(int a[120][120])\r\n        {\r\n            for(int i=1; i<=n; i++)\r\n                for(int j=1; j<=n; j++)\r\n                    for(int k=1; k<=n; k++)\r\n                        if(i!=k&&j!=k&&j!=i&&a[i][j]==0)\r\n                        {\r\n                            a[i][j]=a[i][k]*a[k][j];\r\n                        }\r\n        }\r\n        int main()\r\n        {\r\n            citire();\r\n            rw(a);\r\n            for(int i=1;i<=n;i++)\r\n            {\r\n                if(viz[i]==0)\r\n                { viz[i]=1;\r\n                    fout<<i<<\" \";\r\n                    for(int j=1;j<=n;j++)\r\n                    {\r\n                        if(a[i][j]==1)\r\n                        {\r\n                            fout<<j<<\" \";\r\n                            viz[j]=1;\r\n                        }\r\n                    }\r\n                    fout<<endl;\r\n                }\r\n            }\r\n        }        \r\n        `\r\n    },\r\n    {\r\n        title:'Graf neorientat conex',\r\n        description: 'Vlad Romila pe Facebook doreste sa afle daca un graf neorientat este conex.',\r\n        cerinta:'Sa se verifice daca graful neorientat dat este conex.',\r\n        din:'Se citeste de la tastatura un numar n=numar de noduri si un numar m=numar de muchii si m perechi de extremitati de muchii',\r\n        dout:'Sa se verifice daca graful dat este conex',\r\n        rezolvare:\r\n        `#include <bits/stdc++.h>\r\n\r\n        using namespace std;\r\n        ifstream fin(\"grafconex.in\");\r\n        ofstream fout(\"grafconex.out\");\r\n        int a[21][21],viz[120],gr[120],n,m,marc;\r\n        \r\n        void citire()\r\n        {\r\n            cin>>n>>m;\r\n            int x,y;\r\n            for(int i=1; i<=m; i++)\r\n            {\r\n                cin>>x>>y;\r\n                a[x][y]=a[y][x]=1;\r\n                gr[x]++;\r\n                gr[y]++;\r\n            }\r\n        \r\n        }\r\n        void df(int x)\r\n        {\r\n            viz[x]=marc;\r\n            for(int i=1; i<=n; i++)\r\n            {\r\n                if(i!=x&&viz[i]==0&&a[i][x]==1)\r\n                {\r\n                    df(i);\r\n                }\r\n            }\r\n        }\r\n        \r\n        int main()\r\n        {\r\n            citire();\r\n            for(int i=1; i<=n; i++)\r\n                if(viz[i]==0)\r\n                {\r\n                    marc++;\r\n                    df(i);\r\n                }\r\n            if(marc==1)\r\n                cout<<\"Graful este conex\";\r\n            else\r\n                cout<<\"Graful nu este conex\";\r\n            return 0;\r\n        }\r\n        `\r\n    },\r\n    {\r\n        title:'Graf neorientat conex cu BF',\r\n        description: 'Vlad Romila pe Facebook doreste sa afle daca un graf neorientat este conex.',\r\n        cerinta:'Sa se verifice daca graful neorientat dat este conex.',\r\n        din:'Se citeste de la tastatura un numar n=numar de noduri si un numar m=numar de muchii si m perechi de extremitati de muchii',\r\n        dout:'Sa se verifice daca graful dat este conex',\r\n        rezolvare:\r\n        `#include<fstream>\r\n        using namespace std;\r\n        ifstream fin(\"date.in\");\r\n        ofstream fout(\"date.out\");\r\n        int a[101][101],viz[101],c[101],x,y,n,ok=1;\r\n        \r\n        void Bf(int x)\r\n        {\r\n            int p=1;\r\n            int u=1;\r\n            int z;\r\n            c[1]=x;\r\n            viz[x]=1;\r\n            while(p<=u)\r\n            {\r\n                z=c[p];\r\n                p++;\r\n        \r\n                for(int i=1; i<=n; i++)\r\n                    if(a[z][i]==1&& viz[i]==0)\r\n                    {\r\n                        u++;\r\n                        c[u]=i;\r\n                        viz[i]=1;\r\n                    }\r\n            }\r\n        \r\n        }\r\n        int main()\r\n        {\r\n            fin>>n;\r\n            while(fin>>x>>y)\r\n                a[x][y]=a[y][x]=1;\r\n            Bf(1);\r\n            for(int i=1;i<=n;i++)\r\n        if(viz[i]==0)\r\n        ok=0;\r\n        \r\n        if (ok)\r\n            fout<<\"conex\";\r\n        if(ok==0) fout<<\" nu e conex\";\r\n        }        \r\n        `\r\n    },\r\n    {\r\n        title:'Graf neorientat eulerian',\r\n        description: 'Vlad Romila pe Facebook doreste sa afle daca un graf neorientat este eulerian.',\r\n        cerinta:'Sa se verifice daca graful neorientat dat este eulerian.',\r\n        din:'Se citeste de la tastatura un numar n=numar de noduri si un numar m=numar de muchii si m perechi de extremitati de muchii',\r\n        dout:'Sa se verifice daca graful dat este eulerian.',\r\n        rezolvare:\r\n        `#include <bits/stdc++.h>\r\n\r\n        using namespace std;\r\n        ifstream fin(\"grafconex.in\");\r\n        ofstream fout(\"grafconex.out\");\r\n        int a[21][21],viz[120],gr[120],n,m,marc;\r\n        \r\n        void citire()\r\n        {\r\n            cin>>n>>m;\r\n            int x,y;\r\n            for(int i=1; i<=m; i++)\r\n            {\r\n                cin>>x>>y;\r\n                a[x][y]=a[y][x]=1;\r\n                gr[x]++;\r\n                gr[y]++;\r\n            }\r\n        \r\n        }\r\n        void df(int x)\r\n        {\r\n            viz[x]=marc;\r\n            for(int i=1; i<=n; i++)\r\n            {\r\n                if(i!=x&&viz[i]==0&&a[i][x]==1)\r\n                {\r\n                    df(i);\r\n                }\r\n            }\r\n        }\r\n        \r\n        int main()\r\n        {\r\n            citire();\r\n            for(int i=1; i<=n; i++)\r\n                if(viz[i]==0)\r\n                {\r\n                    marc++;\r\n                    df(i);\r\n                }\r\n        \r\n            if(marc==1)\r\n            {\r\n                int ok=1;\r\n                for(int i=1; i<=n; i++)\r\n                {\r\n                    if(gr[i]%2==1)\r\n                    {\r\n                        ok=0;\r\n                        break;\r\n                    }\r\n                }\r\n                if(ok==1)\r\n                {\r\n                    cout<<\"Graful este eulerian!\";\r\n                }\r\n                else\r\n                    cout<<\"Chiar daca graful este conex, nu este eulerian deoarece are noduri care au graduri impare!\";\r\n            }\r\n            else\r\n                cout<<\"Graful nu este conex asadar nu este nici eulerian!\";\r\n            return 0;\r\n        }        \r\n        `\r\n    },\r\n    {\r\n        title: 'ROY FLOYD',\r\n        description: 'Vlad Romila pe Facebook doreste sa afle costul minim de la orice nod la altul',\r\n        cerinta: 'Sa se creeze un program care sa afiseze matricea de costuri',\r\n        din: 'Se citeste din fisierul n,m si m arce ale unui graf cu costurile lor',\r\n        dout: 'Sa se afiseze matricea de costuri a grafului dat',\r\n        rezolvare:\r\n        `#include <bits/stdc++.h>\r\n        using namespace std;\r\n        ifstream fin(\"rf.in\");\r\n        ofstream fout(\"rf.out\");\r\n        int a[101][101],d[101][101],n,m;\r\n        void citire();\r\n        int main()\r\n        {\r\n            fin>>n>>m;\r\n            for(int i=1; i<=n; i++)\r\n                for(int j=1; j<=n; j++)\r\n                    d[i][j] = 999999;\r\n            citire();\r\n            for(int k=1; k<=n; k++)\r\n                for(int i=1; i<=n; i++)\r\n                    for(int j=1; j<=n; j++)\r\n                        if(d[i][j]>d[i][k]+d[k][j] && (d[i][k]+d[k][j]!=0))\r\n                            d[i][j] = d[i][k]+d[k][j];\r\n            for(int i=1; i<=n; i++)\r\n            {\r\n                for(int j=1; j<=n; j++)\r\n                    if(i==j)\r\n                        fout<<0<<\" \";\r\n                    else if(d[i][j] == 999999)\r\n                        fout<<-1<<\" \";\r\n                    else\r\n                        fout<<d[i][j]<<\" \";\r\n                fout<<endl;\r\n            }\r\n            return 0;\r\n        }\r\n        \r\n        void citire()\r\n        {\r\n            int x,y,c;\r\n            for(int i=1; i<=m; i++)\r\n            {\r\n                fin>>x>>y>>c;\r\n                a[x][y] = d[x][y] = c;\r\n            }\r\n        }        \r\n        `\r\n    },\r\n    {\r\n        title: 'Componente T.C/Graf T.C',\r\n        description: 'Vlad Romila pe Facebook doreste sa afle daca un graf este tare conex sau daca nu care sunt componentele tare conexe',\r\n        cerinta: 'Sa se creeze un program care sa afiseze componentele tare conexe si daca graful dat este sau nu este tare conex (nu prea are sens cerinta dar nu imi bat capul)',\r\n        din: 'Se citeste din fisierul n,m si m arce ale unui graf',\r\n        dout: 'Sa se afiseze componentele tare conexe ale grafului dat si sa se verifice daca graful este tare conex',\r\n        rezolvare:\r\n        `#include <bits/stdc++.h>\r\n        using namespace std;\r\n        ifstream fin(\"ctc.in\");\r\n        ofstream fout(\"ctc.out\");\r\n        \r\n        int a[21][21],atr[21][21],n,m,intersectie[21][21],viz[21];\r\n        void citire()\r\n        {\r\n            int x,y;\r\n            fin>>n>>m;\r\n            for(int i=1; i<=m; i++)\r\n            {\r\n                fin>>x>>y;\r\n                a[x][y]=1;\r\n                atr[y][x]=1;\r\n            }\r\n        }\r\n        void roy(int a[21][21], int n)\r\n        {\r\n            for(int k=1; k<=n; k++)\r\n                for(int i=1; i<=n; i++)\r\n                    for(int j=1; j<=n; j++)\r\n                        if(i!=k&&j!=k&&a[i][j]==0)\r\n                            a[i][j]=a[i][k]*a[k][j];\r\n        }\r\n        int main()\r\n        {\r\n            citire();\r\n            roy(a,n);\r\n            roy(atr,n);\r\n            for(int i=1; i<=n; i++)\r\n                for(int j=1; j<=n; j++)\r\n                    intersectie[i][j]=a[i][j]&&atr[i][j];\r\n            int nr=0;\r\n            for(int i=1; i<=n; i++)\r\n            {\r\n                if(viz[i]==0)\r\n                {\r\n                    viz[i]=1;\r\n                    nr++;\r\n                    fout<<\"Componenta conexa \"<<nr<<\" este: \"<<i<<\" \";\r\n                    for(int j=1; j<=n; j++)\r\n                    {\r\n                        if(i!=j&&intersectie[i][j]==1)\r\n                        {\r\n                            fout<<j<<\" \";\r\n                            viz[j]=1;\r\n                        }\r\n                    }\r\n                    fout<<endl;\r\n                }\r\n            }\r\n            fout<<\"Asadar, numarul total de componente tare conexe este: \"<<nr<<endl;\r\n            if(nr==1)\r\n                fout<<\"Graful este tare conex\";\r\n            else\r\n                fout<<\"Deoarece graful are mai multe componente tare conexe, nu este tare conex\";\r\n            return 0;\r\n        }\r\n        `\r\n    },\r\n    {\r\n        title: \"Facebook_FMI\",\r\n        description: ` Ionuț tocmai a terminat liceul și susține examenul de admitere la facultate. Știind că s-a pregătit foarte bine pentru examen, el dorește să își anunțe reușita după examen printr-o postare pe Facebook.\r\n    Ionuț cunoaște n utilizatori reprezentați de numerele de la 1 la n, între care există m relații de prietenie de forma i j, unde i și j sunt utilizatori, iar n și m sunt numere naturale nenule. Un utilizator nu poate fi prieten cu el însuși, iar o relație de prietenie între doi utilizatori ne spune că fiecare dintre ei este prieten cu celălalt.\r\nÎntrucât dorește ca postarea lui să fie cât mai răspândită, Ionuț vrea să afle care sunt utilizatorii cei mai bine conectați din mulțimea sa de cunoscuți, pentru ca eventual să le ceară prietenia. Pentru aceasta, Ionuț trebuie să găsească cea mai mare submulțime de utilizatori cunoscuți, în care fiecare utilizator din această submulțime are cel puțin k prieteni aflați la rândul lor în submulțime, unde k este un număr natural nenul.`,\r\n        cerinta: ` Ajutați-l pe Ionuț să se determine și să se afișeze, printr-o soluție de complexitate timp cât mai bună, în funcție de datele de intrare, membrii celei mai mari submulțimi de utilizatori, cu proprietatea că fiecare utilizator din această submulțime are cel puțin k prieteni aflați la rândul lor în submulțime.`,\r\n        din: `   Fișierul de intrare fb_fmi.in conține pe prima linie numerele n, m și k, separate prin spațiu, iar pe a doua linie 2•m numere naturale cuprinse între 1 și n, separate prin spațiu, reprezentând în ordine cele m relații de prietenie între cei n utilizatori.`,\r\n        dout: `Fișierul de ieșire fb_fmi.out va conține pe prima linie numărul natural Q ce reprezintă numărul maxim de membrii ai submulțimii de utilizatori care au cel puțin k prieteni, aflați la rândul lor în submulțime.\r\n    Pe următoarea linie, în ordine crescătoare, sunt enumerați utilizatori submulțimii. În cazul în care nu există o astfel de submulțime pentru k dat, în fișier se va scrie valoarea 0.`,\r\n        rezolvare:\r\n            `#include <fstream>\r\n    using namespace std;\r\n    ifstream fin(\"fb_fmi.in\");\r\n    ofstream fout(\"fb_fmi.out\");\r\n    int n,m,k,D[1005],nr;\r\n    bool A[1005][1005],VIZ[1005];\r\n    void citire()\r\n    {\r\n        fin>>n>>m>>k;\r\n        int x,y,i;\r\n        for(i=1;i<=m;i++)\r\n        {\r\n            fin>>x>>y;\r\n            A[x][y]=A[y][x]=1;\r\n            D[x]++;\r\n            D[y]++;\r\n        }\r\n    }\r\n    void df(int x)\r\n    {\r\n        VIZ[x]=1;\r\n        nr++;\r\n        for(int i=1;i<=n;i++)\r\n            if(A[x][i])\r\n        {\r\n            D[i]--;\r\n            if(D[i]<k&&VIZ[i]==0)\r\n                df(i);\r\n        }\r\n    }\r\n    int main()\r\n    {\r\n        citire();\r\n        for(int i=1;i<=n;i++)\r\n            if(D[i]<k&&VIZ[i]==0)\r\n            df(i);\r\n        fout<<n-nr<<endl;\r\n        for(int i=1;i<=n;i++)\r\n            if(VIZ[i]==0)\r\n            fout<<i<<' ';\r\n        return 0;\r\n    }`\r\n    }\r\n]","import React from 'react';\r\nimport { Link } from 'react-router-dom';\r\nimport { data } from './data.js'\r\nclass List extends React.Component {\r\n    constructor() {\r\n        super();\r\n        this.state = {\r\n        }\r\n    }\r\n    render() {\r\n        return (\r\n            <div class=\"col-12 col\" style={{ marginTop: 80 }}>\r\n                <a href=\"http://liis.ro/~infosuport/12/grafuri.pdf\"><button style={{ marginTop: 2 }} class=\"btn-block\">PENTRU TEORIE!</button></a>\r\n                {data.map((obj, i) => {\r\n                    return <Link key={i} to={{ pathname: '/pb', state: obj }}><button style={{ marginTop: 2 }} class=\"btn-block\">{obj.title}</button></Link>\r\n                })}\r\n            </div>\r\n\r\n        )\r\n    }\r\n}\r\nexport default List;","import React, { Component } from 'react';\nimport { BrowserRouter as Router, Route, Link } from 'react-router-dom'\nimport PP from './PP.js';\nimport Landing from './Landing.js';\nimport List from './List.js';\nimport { Nav, Navbar, MenuItem, NavItem, NavDropdown, FormGroup, FormControl, Button } from 'react-bootstrap'\nimport {data} from './data.js';\n\nclass App extends Component {\n  render() {console.log(data);\n    return (\n      <Router>\n        <React.Fragment>\n          <nav className=\"border fixed split-nav\">\n  <div className=\"nav-brand\">\n    <h3><Link to=\"/\">Teoria Grafurilor</Link></h3>\n  </div>\n  <div className=\"collapsible\">\n    <input id=\"collapsible1\" type=\"checkbox\" name=\"collapsible1\"/>\n    <button>\n    <label htmlFor=\"collapsible1\">\n        <div className=\"bar1\"></div>\n        <div className=\"bar2\"></div>\n        <div className=\"bar3\"></div>\n      </label>\n    </button>\n    <div className=\"collapsible-body\">\n      <ul className=\"inline\">\n        <li><Link to=\"/pbs\">Probleme</Link></li>\n      </ul>\n    </div>\n  </div>\n</nav>\n          <Route path=\"atestat/\" exact component={Landing} />\n          <Route path=\"atestat/pbs\" exact component={List} />\n          <Route path=\"atestat/pb\" exact component={PP} />\n          </React.Fragment>\n          \n      </Router>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}